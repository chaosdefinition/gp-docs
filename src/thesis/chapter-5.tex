%% LaTeX source of Chapter 5 of the thesis.
%% NEVER compile this file. Complie 'thesis.tex' instead.

\chapter{结果分析}
\label{Chapter 5}

利用在第 \ref{Chapter 4} 章构建好的分布式计算程序 Hyperspark，
我们对 $3$ 阶和 $4$ 阶超立方体到环的嵌入进行了计算。

\section{示例说明}
\label{Section 5.1}

我们在前文中提到过，
一个从超立方体到环的编号方式可以被视为一个 $0$ 到 $2^d - 1$ 这 $2^d$ 个数的排列。
因此下文中给出的所有结果都将以排列的形式展现出来。
在这里我们以格雷码编号方式 $\mathcal{G} \colon V_{Q_3} \rightarrow V_{C_8}$ 为例，
将 $\mathcal{G}$ 表示为
\begin{equation*}
\mathcal{G} = [0, 1, 3, 2, 6, 7, 5, 4]
\end{equation*}
其中每一个数是 $Q_3$ 上每一个顶点的十进制表示形式。
该排列表示 $Q_3$ 中的顶点 $000$（十进制表示为 $0$）映射到 $C_8$ 中的顶点 $0$（第一个位置）、
$Q_3$ 中的顶点 $001$（十进制表示为 $1$）映射到 $C_8$ 中的顶点 $1$（第二个位置 ）、……、
$Q_3$ 中的顶点 $100$（十进制表示为 $4$）映射到 $C_8$ 中的顶点 $7$（第八个位置 ）。

\section{$3$ 阶情况}
\label{Section 5.2}

首先是 $3$ 阶的计算结果。
$3$ 阶的情况下一共只有 $40,320$ 种编号方式，
在如今的计算机的运算能力下仅依靠未做任何优化的单机计算程序（如算法 \ref{Algorithm 4.4}）
就可以在瞬间得到结果。
因此，我们很自然地选择了 $3$ 阶情况的计算作为验证 Hyperspark 正确性的测试；
而对于程序的运行时间等其他指标，我们在这次计算中将选择性地忽略。

我们先运行算法 \ref{Algorithm 4.9} 的实现，即 Hyperspark。调用
\begin{equation*}
\textnormal{CalculateMinimumWirelength2}(3, 3);
\end{equation*}
其中输入数据为 $d = 3$ 和 $length = 3$，
表示计算 $3$ 阶的情况，并设定初始排列的长度为 $3$。
初始排列的长度决定了我们要将任务划分成多少份，即要把小任务交给多少个从节点进行计算，
其对应关系为
\begin{equation*}
length \rightarrow \frac{(length - 1)!}{2}
\end{equation*}
因为 $0, 1, 2$ 的不带重复的环形排列只有 $1$ 个，
而要往一个 $0, 1, \dots, x - 1$ 的环形排列中插入 $x$ 则有 $x$ 个不带重复的位置可供插入。

通过上述调用，我们最终得到 $3$ 阶情况下的最短线长为 $20$，以及 $48$ 个 $3$ 阶排列：
\begin{align*}
[0, 6, 4, 7, 5, 3, 1, 2], \quad [0, 6, 4, 5, 7, 3, 1, 2], & \quad [0, 4, 6, 7, 5, 3, 1, 2], \quad [0, 4, 6, 5, 7, 3, 1, 2], \\
[0, 3, 1, 7, 5, 6, 4, 2], \quad [0, 3, 1, 5, 7, 6, 4, 2], & \quad [0, 3, 1, 7, 5, 4, 6, 2], \quad [0, 3, 1, 5, 7, 4, 6, 2], \\
[0, 6, 4, 7, 5, 1, 3, 2], \quad [0, 6, 4, 5, 7, 1, 3, 2], & \quad [0, 4, 6, 7, 5, 1, 3, 2], \quad [0, 4, 6, 5, 7, 1, 3, 2], \\
[0, 4, 5, 1, 7, 3, 6, 2], \quad [0, 4, 5, 1, 3, 7, 6, 2], & \quad [0, 4, 5, 1, 7, 3, 2, 6], \quad [0, 4, 5, 1, 3, 7, 2, 6], \\
[0, 4, 1, 5, 7, 3, 6, 2], \quad [0, 4, 1, 5, 3, 7, 6, 2], & \quad [0, 4, 1, 5, 7, 3, 2, 6], \quad [0, 4, 1, 5, 3, 7, 2, 6], \\
[0, 1, 5, 4, 7, 6, 3, 2], \quad [0, 1, 5, 4, 6, 7, 3, 2], & \quad [0, 1, 4, 5, 7, 6, 3, 2], \quad [0, 1, 4, 5, 6, 7, 3, 2], \\
[0, 1, 3, 7, 5, 6, 4, 2], \quad [0, 1, 3, 5, 7, 6, 4, 2], & \quad [0, 1, 3, 7, 5, 4, 6, 2], \quad [0, 1, 3, 5, 7, 4, 6, 2], \\
[0, 5, 1, 7, 3, 6, 2, 4], \quad [0, 5, 1, 3, 7, 6, 2, 4], & \quad [0, 5, 1, 7, 3, 2, 6, 4], \quad [0, 5, 1, 3, 7, 2, 6, 4], \\
[0, 1, 5, 7, 3, 6, 2, 4], \quad [0, 1, 5, 3, 7, 6, 2, 4], & \quad [0, 1, 5, 7, 3, 2, 6, 4], \quad [0, 1, 5, 3, 7, 2, 6, 4], \\
[0, 1, 3, 2, 7, 6, 5, 4], \quad [0, 1, 3, 2, 6, 7, 5, 4], & \quad [0, 1, 3, 2, 7, 6, 4, 5], \quad [0, 1, 3, 2, 6, 7, 4, 5], \\
[0, 1, 5, 4, 7, 6, 2, 3], \quad [0, 1, 5, 4, 6, 7, 2, 3], & \quad [0, 1, 4, 5, 7, 6, 2, 3], \quad [0, 1, 4, 5, 6, 7, 2, 3], \\
[0, 1, 2, 3, 7, 6, 5, 4], \quad [0, 1, 2, 3, 6, 7, 5, 4], & \quad [0, 1, 2, 3, 7, 6, 4, 5], \quad [0, 1, 2, 3, 6, 7, 4, 5]
\end{align*}
注意我们已经在生成全排列的算法中排除了旋转对称和翻转对称这两种“重复情况”，
因此实际情况中的最优排列数肯定会大于 $48$。
并且我们可以对其进行估算：
长为 $n$ 的全排列有 $2 n$ 种对称情况，正如我们在第 \ref{Subsection 4.3.2} 小节所见；
反过来，知道了不带重复的最优排列数，
我们可以估算总的最优排列数为不带重复的最优排列数乘以 $2 n$。
也就是说我们估算 $3$ 阶情况下的最优排列数应该是 $48 \times 2 \times 8 = 768$。

我们接下来运行算法 \ref{Algorithm 4.4} 的实现。调用
\begin{equation*}
\textnormal{CalculateMinimumWirelength}(3);
\end{equation*}
其中输入数据为 $d = 3$，表示计算 $3$ 阶的情况。

通过上述调用，我们得到 $3$ 阶情况下的最短线长为 $20$，以及 $768$ 个 $3$ 阶排列
（由于数据量过大，我们不在这里列出），从而印证了我们的估算。

\section{$4$ 阶情况}
\label{Section 5.3}

下面是 $4$ 阶的计算结果。

\begin{figure}[h!]
	\centering
	\includesvg[width = 0.8\textwidth]{figure-5-1}
	\caption{$Q_4$ 到 $C_{16}$ 的格雷码编号方式}
	\label{Figure 5-1}
\end{figure}
